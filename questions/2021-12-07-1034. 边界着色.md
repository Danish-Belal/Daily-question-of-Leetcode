# [1034. 边界着色](https://leetcode-cn.com/problems/coloring-a-border/)

# 题目描述：

给你一个大小为 `m x n` 的整数矩阵 `grid` ，表示一个网格。另给你三个整数 `row`、`col` 和 `color` 。网格中的每个值表示该位置处的网格块的颜色。

当两个网格块的颜色相同，而且在四个方向中任意一个方向上相邻时，它们属于同一 **连通分量** 。

**连通分量的边界** 是指连通分量中的所有与不在分量中的网格块相邻（四个方向上）的所有网格块，或者在网格的边界上（第一行/列或最后一行/列）的所有网格块。

请你使用指定颜色 `color` 为所有包含网格块 `grid[row][col]` 的 **连通分量的边界** 进行着色，并返回最终的网格 `grid` 。



**示例 1:**

```
输入：grid = [[1,1],[1,2]], row = 0, col = 0, color = 3
输出：[[3,3],[3,2]]
```

 **示例 2:**

```
输入：grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3
输出：[[1,3,3],[2,3,3]]
```

**示例 3**：

```
输入：grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2
输出：[[2,2,2],[2,1,2],[2,2,2]]
```



# 解答：

## C++：

```cpp

```

## JavaScript：

判断四周是否满足条件，再选择进行着色。

```javascript
const colorBorder = (grid, row, col, color) => {
    const [m, n] = [grid.length, grid[0].length];
    const oldColor = grid[row][col];
    const visit = new Set();
    const dfs = (i, j) => {
        if (i < 0 || i >= m || j < 0 || j >= n) return true;
        const index = i * n + j;
        if (visit.has(index)) return false;
        if (grid[i][j] !== oldColor) return true;
        visit.add(index);
        let flag = false;
        if (dfs(i + 1, j)) flag = true;
        if (dfs(i, j + 1)) flag = true;
        if (dfs(i - 1, j)) flag = true;
        if (dfs(i, j - 1)) flag = true;
        if (flag) grid[i][j] = color;
        return false;
    };
    dfs(row, col);
    return grid;
};
```

## C：

```c

```

## Java :

```java

```
