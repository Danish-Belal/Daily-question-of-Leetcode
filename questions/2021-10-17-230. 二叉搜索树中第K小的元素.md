# [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

# 题目描述：

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

**示例1 ：**

![](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)

```
输入：root = [3,1,4,null,2], k = 1
输出：1
```

**示例2 ：**

![](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)

```
输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3
```



# 解答：

## C++：

> 用有序集存储，再访问第k个元素即可

```C++
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        set<int> xset;
        queue<TreeNode*> Q;
        Q.push(root);
        while(!Q.empty()){
            int size=Q.size();
            for(int i=0;i<size;++i){
                xset.insert(Q.front()->val);
                if(Q.front()->left) Q.push(Q.front()->left);
                if(Q.front()->right) Q.push(Q.front()->right);
                Q.pop();
            }
        }
        auto pos=xset.begin();
        for(int i=0;i<k-1;++i){
            pos++;
        }
        return *pos;
    }
};
```

## JavaScript：

因为是二叉搜索树，中序遍历后是一个有序数组，就可以得到第`K`小的元素。

所以中序遍历二叉搜索树，最后返回第`k-1`个元素。

具体有**递归版**和**非递归版**。

**递归版**：

```javascript
const kthSmallest = (root, k) => {
    const res = [];
    const inOrder = root => {
        if (!root) return;
        // 左
        inOrder(root.left);
        // 根
        res.push(root.val);
        // 右
        inOrder(root.right);
    };
    inOrder(root);
    return res[k - 1];
};
```

**非递归版**：

```javascript
const kthSmallest = (root, k) => {
    const res = [];
    const stack = [];
    let p = root;
    while (stack.length || p) {
        while (p) {
            stack.push(p);
            p = p.left;
        }
        const node = stack.pop();
        res.push(node.val);
        p = node.right;
    }
    return res[k - 1];
};
```

## C：

```c

```

## Java：

```java
class Solution {
    void dfs(TreeNode root,List<TreeNode> list){
        if(root == null){
            return;
        }
        dfs(root.left,list);
        list.add(root);
        dfs(root.right,list);
    }
    public int kthSmallest(TreeNode root, int k) {
        List<TreeNode> list = new ArrayList<>();
        dfs(root,list);
        return list.get(k - 1).val;
    }
}
```

## Python：

```python

```

