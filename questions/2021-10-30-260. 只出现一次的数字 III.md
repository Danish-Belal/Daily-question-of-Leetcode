# [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)

# 题目描述：

给定一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 **任意顺序** 返回答案。

你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

**示例1 ：**

```
输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。
```

**示例2 ：**

```
输入：nums = [-1,0]
输出：[-1,0]
```

**示例3 ：**

```
输入：nums = [0,1]
输出：[1,0]
```



# 解答：

## C++：

```cpp

```

## JavaScript：

这道题和[136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)解法类似。

异或运算：
1. `0`和**任何数**异或=**任何数本身**
2. **任何数**和**自身**异或=`0`
3. 异或满足**交换律**、**结合律**

知道了以上三条，就可以解题了。

总体思路，将`nums`的数按照一定规则分成两组，相同的数必然会被分到一组，关键是**两个不同的数一定要分在不同组**。再每组进行异或，得到的结果就是原数组中两个不同的数，具体如下：

- 首先从0开始，与数组中所有的数进行异或，得到结果`temp`
- `temp`等价为数组中两个不同的数**异或的结果**
- 寻找`temp`中，为`1`的最低的位`k`。例如`[1,2,1,3,2,5]`，得到`temp=6`，也就是`110`，`110`的为`1`的最低的位是第1位，则`k=10`
- `temp`为`110`，是`011`和`101`异或的结果，为`1`的最低位代表两个不同的数，在这一位上不同。那么让两个不同的数，和`k`进行**与**操作，就能分开了
- 分组，`011&10`，`101&10`，可以将两个不同的数分在两组，其余相同的数肯定会被分在同一组
- 每组分别进行异或运算，得到两个答案

```JavaScript
const singleNumber = nums => {
    let temp = 0;
    const len = nums.length;
    for (let i = 0; i < len; i++) {
        temp = temp ^ nums[i];
    }
    // 此时temp是两个不同的数异或的结果
    // 寻找k，k是temp最低位为1、其余位是0的二进制数
    let k = 1;
    while ((temp & k) === 0) k = k << 1;

    let [num1, num2] = [0, 0];
    for (let i = 0; i < len; i++) {
        // 分组，目的是将两个不同的数分开
        if (nums[i] & k) {
            num1 = num1 ^ nums[i];
        } else {
            num2 = num2 ^ nums[i];
        }
    }
    return [num1, num2];
};
```

## C：

```c

```

## Java：
- 利用相同数异或为`0`的特性将数组所有数进行异或，得到`xor`，`xor`则为待寻找的两不同数的异或值
- 利用待寻找的两个数的不同特性将数组分为两组，这里可以利用`xor`的最低位`1`，即两个数在该位分别为`0`,`1`。
- 分为两组后，每组的异或值就是待寻找的数。
```java
class Solution {
    public int[] singleNumber(int[] nums) {
        int xor = 0;
        //xor为待寻找的两不同数的异或值
        for(int i = 0;i < nums.length;i++){
            xor ^= nums[i];
        }
        //xor的最低位1的掩码
        int lowestOneBit = Integer.lowestOneBit(xor);
        int num1 = 0,num2 = 0;
        //分为两组后，每组的异或值就是待寻找的数。
        for(int i = 0;i < nums.length;i++){
            if((nums[i] & lowestOneBit) != 0){
                num1 ^= nums[i];
            }else{
                num2 ^= nums[i];
            }
        }
        return new int[]{num1,num2};
    }
}
```

## Python：

```python

```
