# [335. 路径交叉](https://leetcode-cn.com/problems/self-crossing/)

# 题目描述：

给你一个整数数组 `distance` 。

从 **X-Y** 平面上的点 `(0,0)` 开始，先向北移动 `distance[0]` 米，然后向西移动 `distance[1]` 米，向南移动 `distance[2]` 米，向东移动 `distance[3]` 米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。

 判断你所经过的路径是否相交。如果相交，返回 `true` ；否则，返回 `false` 。

**示例1 ：**

![](https://assets.leetcode.com/uploads/2021/03/14/selfcross1-plane.jpg)

```
输入：distance = [2,1,1,2]
输出：true
```

**示例2 ：**

![](https://assets.leetcode.com/uploads/2021/03/14/selfcross2-plane.jpg)

```
输入：distance = [1,2,3,4]
输出：false
```

**示例3 ：**

![](https://assets.leetcode.com/uploads/2021/03/14/selfcross3-plane.jpg)

```
输入：distance = [1,1,1,1]
输出：true
```



# 解答：

## C++：
```cpp

```

## JavaScript：

相交有3种情况，写出三种情况的线段长度关系：

情况1：

`i>=3`

![](https://jack-img.oss-cn-hangzhou.aliyuncs.com/img/20211029081556.png)

情况2：

`i>=4`

![](https://jack-img.oss-cn-hangzhou.aliyuncs.com/img/20211029081618.png)

情况3：

`i>=5`

![](https://jack-img.oss-cn-hangzhou.aliyuncs.com/img/20211029081635.png)

```JavaScript
const isSelfCrossing = distance => {
    const n = distance.length;
    for (let i = 3; i < n; i++) {
        // 第一类
        if (distance[i - 1] <= distance[i - 3] && distance[i] >= distance[i - 2]) {
            return true;
        }
        // 第二类
        if (
            i >= 4 &&
            distance[i - 1] === distance[i - 3] &&
            distance[i] >= distance[i - 2] - distance[i - 4]
        ) {
            return true;
        }
        // 第三类
        if (
            i >= 5 &&
            distance[i - 1] >= distance[i - 3] - distance[i - 5] &&
            distance[i - 1] <= distance[i - 3] &&
            distance[i - 2] > distance[i - 4] &&
            distance[i] >= distance[i - 2] - distance[i - 4]
        ) {
            return true;
        }
    }
    return false;
};
```

## C：

```c

```

## Java：

```java

```

## Python：

```python

```

