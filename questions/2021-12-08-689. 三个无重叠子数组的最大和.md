# [689. 三个无重叠子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/)

# 题目描述：

给你一个整数数组 `nums` 和一个整数 `k` ，找出三个长度为 `k` 、互不重叠、且 `3 * k` 项的和最大的子数组，并返回这三个子数组。

以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置（下标从 **0** 开始）。如果有多个结果，返回字典序最小的一个。



**示例 1:**

```
输入：nums = [1,2,1,2,6,7,5,1], k = 2
输出：[0,3,5]
解释：子数组 [1, 2], [2, 6], [7, 5] 对应的起始下标为 [0, 3, 5]。
也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。
```

 **示例 2:**

```
输入：nums = [1,2,1,2,1,2,1,2,1], k = 2
输出：[0,2,4]
```



# 解答：

## C++：

```cpp

```

## JavaScript：

```javascript
const maxSumOfThreeSubarrays = (nums, k) => {
    const n = nums.length;
    const dp = Array.from(nums, () => Array.from({ length: 2 }, () => [-1, 0]));
    let max = 0;
    let ans = [-1, -1, -1];
    let win = 0;
    for (let i = 0; i < n; i++) {
        win += nums[i];
        const j = i - k + 1;
        if (j < 0) continue;
        dp[j][0][1] = win;
        for (let h = 0; h <= j - k; h++) {
            if (dp[h][1][1] + win > max) {
                max = dp[h][1][1] + win;
                ans = [dp[h][1][0], h, j];
            }
            if (dp[h][0][1] + win > dp[j][1][1]) {
                dp[j][1][0] = h;
                dp[j][1][1] = win + dp[h][0][1];
            }
        }
        win -= nums[j];
    }
    return ans;
};
```

## C：

```c

```

## Java :

```java

```
