# [352. 将数据流变为多个不相交区间](https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/)

# 题目描述：

给你一个由非负整数 `a1, a2, ..., an` 组成的数据流输入，请你将到目前为止看到的数字总结为不相交的区间列表。

实现 `SummaryRanges` 类：

- `SummaryRanges()` 使用一个空数据流初始化对象。
- `void addNum(int val)` 向数据流中加入整数 `val` 。
- `int[][] getIntervals()` 以不相交区间 `[starti, endi]` 的列表形式返回对数据流中整数的总结。



**示例1 ：**

```
输入：
["SummaryRanges", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals"]
[[], [1], [], [3], [], [7], [], [2], [], [6], []]
输出：
[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]

解释：
SummaryRanges summaryRanges = new SummaryRanges();
summaryRanges.addNum(1);      // arr = [1]
summaryRanges.getIntervals(); // 返回 [[1, 1]]
summaryRanges.addNum(3);      // arr = [1, 3]
summaryRanges.getIntervals(); // 返回 [[1, 1], [3, 3]]
summaryRanges.addNum(7);      // arr = [1, 3, 7]
summaryRanges.getIntervals(); // 返回 [[1, 1], [3, 3], [7, 7]]
summaryRanges.addNum(2);      // arr = [1, 2, 3, 7]
summaryRanges.getIntervals(); // 返回 [[1, 3], [7, 7]]
summaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]
summaryRanges.getIntervals(); // 返回 [[1, 3], [6, 7]]
```



# 解答：

## JavaScript：

1. `SummaryRanges`：初始化一个空数组`nums`。
2. `addNum`：向`nums`中添加数，若数组中已经存在，则不添加。添加后，进行升序排序。
3. `getIntervals`：定义返回区间数组`area`，遍历`nums`。若`area`为空，则直接放入一个单个数区间。不为空，则判断最后一个区间的右边界比当前数小1，若满足则更新这个右边界，否则，单独放入一个单个数区间。

```javascript
var SummaryRanges = function () {
    this.nums = [];
};

SummaryRanges.prototype.addNum = function (val) {
    // 如果nums中重复的数，则不添加
    if (this.nums.includes(val)) return;
    // 添加并升序排序
    this.nums.push(val);
    this.nums.sort((a, b) => a - b);
};

SummaryRanges.prototype.getIntervals = function () {
    const len = this.nums.length;
    // 定义要返回的区间数组
    const area = [];
    if (!len) return area;
    // 遍历nums
    for (let i = 0; i < len; i++) {
        // 当前数
        const curNum = this.nums[i];
        if (!area.length) {
            // 若area为空，则直接放入一个单个数区间
            area.push([curNum, curNum]);
        } else {
            // 最后一个区间
            const lastArea = area[area.length - 1];
            if (lastArea[1] + 1 === curNum) {
                // 若最后一个区间的右边界比当前数小1
                // 则更新这个右边界
                lastArea[1]++;
            } else {
                // 否则，单独放入一个单个数区间
                area.push([curNum, curNum]);
            }
        }
    }
    return area;
};
```

