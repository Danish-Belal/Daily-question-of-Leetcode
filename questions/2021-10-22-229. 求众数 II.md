# [66. 加一](https://leetcode-cn.com/problems/plus-one/)

# 题目描述：

给定一个大小为 *n* 的整数数组，找出其中所有出现超过 `⌊ n/3 ⌋` 次的元素。



**示例1 ：**

```
输入：[3,2,3]
输出：[3]
```

**示例2：**

```
输入：nums = [1]
输出：[1]
```



# 解答：

## C++：

```C++

```

## JavaScript：

摩尔投票法，3个数相抵消，可以求出次数大于`n/3`的元素。

用两组`element`和`vote`变量代表当前投票的元素、投票数。

1. 首次遇到`num`，更新`element`，投票数`vote`加一
2. 若再次遇到`num`，投票数`vote`加一
3. 若遇到第三个数，抵消一次，即两个`vote`减一
4. 最后统计剩下的数出现的次数，判断其是否大于`n/3`

```javascript
const majorityElement = nums => {
    // 元素和票数
    let [element1, element2] = [0, 0];
    let [vote1, vote2] = [0, 0];

    for (const num of nums) {
        if (vote1 && num === element1) {
            // 再次遇到num，投票加一
            vote1++;
        } else if (vote2 && num === element2) {
            vote2++;
        } else if (!vote1) {
            // 第一次遇到num，更新element，投票加一
            element1 = num;
            vote1++;
        } else if (!vote2) {
            element2 = num;
            vote2++;
        } else {
            // 遇到第三个数，抵消一次
            vote1--;
            vote2--;
        }
    }

    // 统计剩下数出现的次数
    let [count1, count2] = [0, 0];
    for (const num of nums) {
        if (vote1 && num === element1) count1++;
        if (vote2 && num === element2) count2++;
    }

    // 判断出现的次数是否大于n/3
    const res = [];
    if (vote1 && count1 > Math.floor(nums.length / 3)) res.push(element1);
    if (vote2 && count2 > Math.floor(nums.length / 3)) res.push(element2);

    return res;
};
```

## C：
```c

```

## Java：
```java

```

## Python：

```python

```

